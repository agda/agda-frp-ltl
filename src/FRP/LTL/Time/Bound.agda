open import Data.Empty using ( ⊥-elim )
open import Data.Product using ( _×_ ; _,_ )
open import Data.Sum using ( _⊎_ ; inj₁ ; inj₂ )
open import Relation.Binary.PropositionalEquality using ( _≡_ ; _≢_ ; refl ; cong )
open import Relation.Nullary using ( ¬_ )
open import FRP.LTL.Time using ( Time ; _<_ ; _≤_ ; ≤-refl ; _≤-trans_ ; _≤-asym_ ; _≤-total_ ; ≤-proof-irrel )

module FRP.LTL.Time.Bound where

infixr 2 _≼_ _≺_ _⋠_ 
infixr 5 _≼-trans_ _≼-asym_ _≼-total_ _≺-transˡ_ _≺-transʳ_

-- Time bounds, which extend Time with least and greatest elements

data Time∞ : Set where
  +∞ : Time∞
  fin : Time → Time∞

-- Order on time, generated by s ≺ t ≺ +∞ when s < t

data _≼_ : Time∞ → Time∞ → Set where
  +∞-top : ∀ {t} → (t ≼ +∞)
  ≤-impl-≼ : ∀ {t u} → (t ≤ u) → (fin t ≼ fin u)

_⋠_ : Time∞ → Time∞ → Set 
s ⋠ t = ¬(s ≼ t)

_≺_ : Time∞ → Time∞ → Set 
s ≺ t = (s ≼ t) × (t ⋠ s)

≼-impl-≤ : ∀ {t u} → (fin t ≼ fin u) → (t ≤ u)
≼-impl-≤ (≤-impl-≼ t≤u) = t≤u

-- Axioms for ≺

t≺+∞ : ∀ {t} → fin t ≺ +∞
t≺+∞ = (+∞-top , λ ())

<-impl-≺ : ∀ {t u} → (t < u) → (fin t ≺ fin u)
<-impl-≺ (t≤u , u≰t) = (≤-impl-≼ t≤u , λ u≼t → u≰t (≼-impl-≤ u≼t))

-- ≼ is a decidable total order

≼-refl : ∀ {t} → (t ≼ t)
≼-refl {+∞}     = +∞-top
≼-refl {fin t} = ≤-impl-≼ ≤-refl

_≼-trans_ : ∀ {s t u} → (s ≼ t) → (t ≼ u) → (s ≼ u)
s≼t          ≼-trans +∞-top       = +∞-top
≤-impl-≼ s≤t ≼-trans ≤-impl-≼ t≤u = ≤-impl-≼ (s≤t ≤-trans t≤u)

_≼-asym_ : ∀ {s t} → (s ≼ t) → (t ≼ s) → (s ≡ t)
+∞-top       ≼-asym +∞-top       = refl
≤-impl-≼ s≤t ≼-asym ≤-impl-≼ t≤s = cong fin (s≤t ≤-asym t≤s)

_≼-total_ : ∀ s t → (s ≼ t) ⊎ (t ≺ s)
+∞    ≼-total +∞    = inj₁ +∞-top
+∞    ≼-total fin t = inj₂ t≺+∞
fin s ≼-total +∞    = inj₁ +∞-top
fin s ≼-total fin t with s ≤-total t
... | inj₁ s≤t = inj₁ (≤-impl-≼ s≤t)
... | inj₂ t<s = inj₂ (<-impl-≺ t<s)

≡-impl-≼ : ∀ {s t} → (s ≡ t) → (s ≼ t)
≡-impl-≼ refl = ≼-refl

≡-impl-≽ : ∀ {s t} → (s ≡ t) → (t ≼ s)
≡-impl-≽ refl = ≼-refl

≼-proof-irrel : ∀ {t u} → (p q : t ≼ u) → (p ≡ q)
≼-proof-irrel +∞-top          +∞-top          = refl
≼-proof-irrel (≤-impl-≼ t≤₁u) (≤-impl-≼ t≤₂u) = cong ≤-impl-≼ (≤-proof-irrel t≤₁u t≤₂u)

≺-impl-≼ : ∀ {t u} → (t ≺ u) → (t ≼ u)
≺-impl-≼ (t≼u , u⋠t) = t≼u

≺-impl-⋡ : ∀ {t u} → (t ≺ u) → (u ⋠ t)
≺-impl-⋡ (t≼u , u⋠t) = u⋠t

≺-impl-≢ : ∀ {t u} → (t ≺ u) → (t ≢ u)
≺-impl-≢ (t≼u , u⋠t) refl = u⋠t ≼-refl

_≺-transˡ_ : ∀ {t u v} → (t ≺ u) → (u ≼ v) → (t ≺ v)
_≺-transˡ_ (t≼u , u⋠t) u≼v = (t≼u ≼-trans u≼v , λ v≼t → u⋠t (u≼v ≼-trans v≼t))

_≺-transʳ_ : ∀ {t u v} → (t ≼ u) → (u ≺ v) → (t ≺ v)
_≺-transʳ_ t≼u (u≼v , v⋠u) = (t≼u ≼-trans u≼v , λ v≼t → v⋠u (v≼t ≼-trans t≼u))

∞≼-impl-≡∞ : ∀ {t} → (+∞ ≼ t) → (t ≡ +∞)
∞≼-impl-≡∞ +∞-top = refl

src : ∀ {s t} → .(s ≼ t) → Time∞
src {s} {t} s≼t = s

tgt : ∀ {s t} → .(s ≼ t) → Time∞
tgt {s} {t} s≼t = t
