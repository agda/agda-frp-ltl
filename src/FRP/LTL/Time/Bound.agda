open import Data.Nat using ( ℕ ; zero ; suc )
open import Data.Product using ( ∃ ; _×_ ; _,_ )
open import Data.Sum using ( _⊎_ ; inj₁ ; inj₂ )
open import Relation.Binary.PropositionalEquality using ( _≡_ ; _≢_ ; refl ; cong )
open import Relation.Nullary using ( ¬_ )
open import FRP.LTL.Time using 
  ( Time ; _<_ ; _≤_ ; _≥_ ; ≤-refl ; _≤-trans_ ; _≤-asym_ ; _≤-total_ ; ≤-proof-irrel ; ≡-impl-≥
  ; _∸_ ; _+_ ; t≤u+t∸u ; +-unit ; +-assoc ; +-resp-≤ ; <-impl-+1≤ 
  ; _≤-case_ ; lt ; eq ; gt )
open import FRP.LTL.Util using ( ⊥-elim )

module FRP.LTL.Time.Bound where

infixr 2 _≼_ _≺_ _⋠_ 
infixr 4 _,_
infixr 5 _≼-trans_ _≼-asym_ _≼-total_ _≺-transˡ_ _≺-transʳ_

-- Time bounds, which extend Time with least and greatest elements

data Time∞ : Set where
  +∞ : Time∞
  fin : Time → Time∞

-- Order on time, generated by s ≺ t ≺ +∞ when s < t

data _≼_ : Time∞ → Time∞ → Set where
  +∞-top : ∀ {t} → (t ≼ +∞)
  ≤-impl-≼ : ∀ {t u} → (t ≤ u) → (fin t ≼ fin u)

_⋠_ : Time∞ → Time∞ → Set 
s ⋠ t = ¬(s ≼ t)

_≺_ : Time∞ → Time∞ → Set 
s ≺ t = (s ≼ t) × (t ⋠ s)

≼-impl-≤ : ∀ {t u} → (fin t ≼ fin u) → (t ≤ u)
≼-impl-≤ (≤-impl-≼ t≤u) = t≤u

-- Axioms for ≺

t≺+∞ : ∀ {t} → fin t ≺ +∞
t≺+∞ = (+∞-top , λ ())

<-impl-≺ : ∀ {t u} → (t < u) → (fin t ≺ fin u)
<-impl-≺ (t≤u , u≰t) = (≤-impl-≼ t≤u , λ u≼t → u≰t (≼-impl-≤ u≼t))

≺-impl-< : ∀ {t u} → (fin t ≺ fin u) → (t < u)
≺-impl-< (t≼u , u⋠t) = (≼-impl-≤ t≼u , λ u≤t → u⋠t (≤-impl-≼ u≤t))

-- ≼ is a decidable total order

≼-refl : ∀ {t} → (t ≼ t)
≼-refl {+∞}     = +∞-top
≼-refl {fin t} = ≤-impl-≼ ≤-refl

_≼-trans_ : ∀ {s t u} → (s ≼ t) → (t ≼ u) → (s ≼ u)
s≼t          ≼-trans +∞-top       = +∞-top
≤-impl-≼ s≤t ≼-trans ≤-impl-≼ t≤u = ≤-impl-≼ (s≤t ≤-trans t≤u)

_≼-asym_ : ∀ {s t} → (s ≼ t) → (t ≼ s) → (s ≡ t)
+∞-top       ≼-asym +∞-top       = refl
≤-impl-≼ s≤t ≼-asym ≤-impl-≼ t≤s = cong fin (s≤t ≤-asym t≤s)

_≼-total_ : ∀ s t → (s ≼ t) ⊎ (t ≺ s)
+∞    ≼-total +∞    = inj₁ +∞-top
+∞    ≼-total fin t = inj₂ t≺+∞
fin s ≼-total +∞    = inj₁ +∞-top
fin s ≼-total fin t with s ≤-total t
... | inj₁ s≤t = inj₁ (≤-impl-≼ s≤t)
... | inj₂ t<s = inj₂ (<-impl-≺ t<s)

data _≼-Case_ (t u : Time∞) : Set where
  lt : .(t ≺ u) → (t ≼-Case u)
  eq : .(t ≡ u) → (t ≼-Case u)
  gt : .(u ≺ t) → (t ≼-Case u)

_≼-case_ : ∀ t u → (t ≼-Case u)
+∞    ≼-case +∞    = eq refl
+∞    ≼-case fin u = gt t≺+∞
fin t ≼-case +∞    = lt t≺+∞
fin t ≼-case fin u with t ≤-case u
fin t ≼-case fin u | lt t<u = lt (<-impl-≺ t<u)
fin t ≼-case fin u | eq t≡u = eq (cong fin t≡u)
fin t ≼-case fin u | gt t>u = gt (<-impl-≺ t>u)

≡-impl-≼ : ∀ {s t} → (s ≡ t) → (s ≼ t)
≡-impl-≼ refl = ≼-refl

≡-impl-≽ : ∀ {s t} → (s ≡ t) → (t ≼ s)
≡-impl-≽ refl = ≼-refl

≼-proof-irrel : ∀ {t u} → (p q : t ≼ u) → (p ≡ q)
≼-proof-irrel +∞-top          +∞-top          = refl
≼-proof-irrel (≤-impl-≼ t≤₁u) (≤-impl-≼ t≤₂u) = cong ≤-impl-≼ (≤-proof-irrel t≤₁u t≤₂u)

≺-impl-≼ : ∀ {t u} → (t ≺ u) → (t ≼ u)
≺-impl-≼ (t≼u , u⋠t) = t≼u

≺-impl-⋡ : ∀ {t u} → (t ≺ u) → (u ⋠ t)
≺-impl-⋡ (t≼u , u⋠t) = u⋠t

≺-impl-≢ : ∀ {t u} → (t ≺ u) → (t ≢ u)
≺-impl-≢ (t≼u , u⋠t) refl = u⋠t ≼-refl

_≺-transˡ_ : ∀ {t u v} → (t ≺ u) → (u ≼ v) → (t ≺ v)
_≺-transˡ_ (t≼u , u⋠t) u≼v = (t≼u ≼-trans u≼v , λ v≼t → u⋠t (u≼v ≼-trans v≼t))

_≺-transʳ_ : ∀ {t u v} → (t ≼ u) → (u ≺ v) → (t ≺ v)
_≺-transʳ_ t≼u (u≼v , v⋠u) = (t≼u ≼-trans u≼v , λ v≼t → v⋠u (v≼t ≼-trans t≼u))

∞≼-impl-≡∞ : ∀ {t} → (+∞ ≼ t) → (t ≡ +∞)
∞≼-impl-≡∞ +∞-top = refl

src : ∀ {s t} → .(s ≼ t) → Time∞
src {s} {t} s≼t = s

tgt : ∀ {s t} → .(s ≼ t) → Time∞
tgt {s} {t} s≼t = t

-- An induction scheme for time bounds

_+_≻_ : Time∞ → ℕ → Time∞ → Set
s + zero  ≻ u = u ≺ s
s + suc n ≻ u = ∀ {t} → (s ≺ t) → (t + n ≻ u)

data ≺-Indn (s u : Time∞) : Set where
  _,_ : ∀ n → .(s + n ≻ u) → ≺-Indn s u

≺-indn : ∀ {s u} → .(u ≺ +∞) → ≺-Indn s u
≺-indn {s}     {+∞}    u≺∞ = ⊥-elim (≺-impl-≢ u≺∞ refl)
≺-indn {+∞}    {fin u} u≺∞ = (zero , t≺+∞)
≺-indn {fin s} {fin u} u≺∞ = (suc (u ∸ s) , lemma s u (u ∸ s) t≤u+t∸u) where

  lemma : ∀ s u n → (s + n ≥ u) → (fin s + suc n ≻ fin u)
  lemma s u zero    s+0≥u   s≺t = 
    (≤-impl-≼ s+0≥u ≼-trans ≡-impl-≼ (cong fin (+-unit s))) ≺-transʳ s≺t
  lemma s u (suc n) s+1+n≥u {fin t} s≺t = lemma t u n 
    (s+1+n≥u ≤-trans ≡-impl-≥ (+-assoc s 1 n) ≤-trans +-resp-≤ (<-impl-+1≤ (≺-impl-< s≺t)) n)
  lemma s u (suc n) s+1+n≥u {+∞} s≺t = 
    λ ∞≺v → ⊥-elim (≺-impl-⋡ ∞≺v +∞-top)
